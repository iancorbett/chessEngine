<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>JS Chess Engine (vs You)</title>

  <!-- Modern chessboard as a Web Component -->
  <script type="module" src="https://unpkg.com/chessboard-element?module"></script>

  <style>
    body { font-family: system-ui, sans-serif; padding: 20px; }
    chess-board { width: 420px; margin-bottom: 12px; display: block; }
    #log { white-space: pre-wrap; font-family: ui-monospace, monospace; margin-top: 10px; }
    button { padding: 8px 12px; }
    input { padding: 4px 6px; width: 90px; }
  </style>
</head>
<body>
  <h1>Play vs JS Engine</h1>

  <!-- The board -->
  <chess-board id="board" draggable-pieces></chess-board>

  <div style="margin: 8px 0;">
    <button id="newGame">New Game</button>
    <span style="margin-left:8px">
      Engine time: <input id="thinkMs" type="number" value="1200"> ms
    </span>
  </div>

  <div id="log"></div>

  <script type="module">
    // ESM build of chess.js
    import { Chess } from 'https://cdn.jsdelivr.net/npm/chess.js@1.0.0/dist/esm/chess.js';

    // Start the engine as a MODULE worker (engine.worker.js must also be ESM)
    const engine = new Worker('./engine.js', { type: 'module' });

    // Game state & UI
    const game = new Chess();
    const board = document.getElementById('board');
    const logEl = document.getElementById('log');
    const thinkMsEl = document.getElementById('thinkMs');

    // Initial position
    board.setAttribute('position', 'start');

    function appendLog(line) {
      logEl.textContent = (line + '\n' + logEl.textContent).slice(0, 8000);
    }

    // Handle user moves
    board.addEventListener('drop', (e) => {
      const { source, target, setAction } = e.detail;

      // same-square drop â†’ snap back
      if (source === target) {
        setAction('snapback');
        return;
      }

      // Try to make the move (chess.js v1 may throw on illegal)
      try {
        const move = game.move({ from: source, to: target, promotion: 'q' });
        if (!move) { setAction('snapback'); return; }  // safety if null is returned

        board.setAttribute('position', game.fen());
        appendLog(`You: ${move.san}`);
        thinkForEngine();
      } catch {
        setAction('snapback');
      }
    });

    // Keep board synced after animations
    board.addEventListener('snap-end', () => {
      board.setAttribute('position', game.fen());
    });

    function thinkForEngine() {
      if (game.isGameOver()) return; // v1 API
      engine.postMessage({
        type: 'go',
        fen: game.fen(),
        timeMs: Number(thinkMsEl.value) || 1000,
        depth: 6
      });
    }

    engine.onmessage = (e) => {
      const msg = e.data || {};
      if (msg.type === 'bestmove') {
        if (!msg.uci) return;
        const from = msg.uci.slice(0, 2);
        const to   = msg.uci.slice(2, 4);
        const promotion = msg.uci.slice(4) || undefined;

        try {
          const made = game.move({ from, to, promotion });
          if (made) {
            board.setAttribute('position', game.fen());
            appendLog(`Engine: ${made.san}  (score ${msg.scoreCp}, nodes ${msg.nodes})`);
          }
        } catch (err) {
          appendLog('Engine move invalid: ' + (err?.message || err));
        }
      } else if (msg.type === 'error') {
        appendLog('Engine error: ' + msg.error);
      }
    };

    document.getElementById('newGame').onclick = () => {
      game.reset();
      board.setAttribute('position', 'start');
      logEl.textContent = '';
    };
  </script>
</body>
</html>
